#ifndef _DEFS_H_
#define _DEFS_H_

#include <Adafruit_GFX.h>
#include <FastLED_NeoMatrix.h>
#include <FastLED.h>


typedef void (*doOnFileFoundCallback)(const char * dirname, const char * fileName);
typedef void (*taskFunctionPtr)(void * pvParameters);


// Max is 255, 32 is a conservative value to not overload
// a USB power supply (500mA) for 12x12 pixels.
#define BRIGHTNESS 4
#define MX_COLORS 3
#define MX_WIDTH 16
#define MX_HEIGHT 16
#define NUM_LEDS (MX_WIDTH*MX_HEIGHT)
#define BITMAP_SIZE ( NUM_LEDS * MX_COLORS )

// Choose your prefered pixmap
#include "bitmaps/heart24.h"
#include "bitmaps/yellowsmiley24.h"
#include "bitmaps/bluesmiley24.h"
#include "bitmaps/smileytongue24.h"
#include "bitmaps/google32.h"
#include "bitmaps/linux32.h"


struct bitmapInfo
{
  const unsigned short* bitmap;    //  Far addresses are untyped 32 bit integers.
  uint8_t width;  
  uint8_t height;
  byte flags;
};

const char bitmapsCount = 6;

bitmapInfo bitmapsData[bitmapsCount] = {  
//  { &converted[0], 16, 16, 0 },
  { &bluesmiley24[0], 24, 24, 0 },
  { &google32[0], 32, 32, 0 },
  { &heart24[0], 24, 24, 0 },
  { &linux32[0], 32, 32, 0 },
  { &smiley24[0], 24, 24, 0 },
  { &yellowsmiley24[0], 24, 24, 0 }
};

//#ifndef PSTR
// #define PSTR // Make Arduino Due happy
//#endif

// Allow temporaly dithering, does not work with ESP32 right now
#ifndef ESP32
#define delay FastLED.delay
#endif

//#if defined(ESP32) or defined(ESP8266)
//#define PIN 12 // GPIO5 = D1
//#else
//#define PIN 13
//#endif


//#define P16BY16X4
////#define P32BY8X3
//#if defined(P16BY16X4) || defined(P32BY8X3)
//#define BM32
//#endif
//
//#ifdef BM32
//#include "google32.h"
//// Anything with black does not look so good with the naked eye (better on pictures)
////#include "linux32.h"
//#endif





// https://learn.adafruit.com/adafruit-neopixel-uberguide/neomatrix-library
// MATRIX DECLARATION:
// Parameter 1 = width of EACH NEOPIXEL MATRIX (not total display)
// Parameter 2 = height of each matrix
// Parameter 3 = number of matrices arranged horizontally
// Parameter 4 = number of matrices arranged vertically
// Parameter 5 = pin number (most are valid)
// Parameter 6 = matrix layout flags, add together as needed:
//   NEO_MATRIX_TOP, NEO_MATRIX_BOTTOM, NEO_MATRIX_LEFT, NEO_MATRIX_RIGHT:
//     Position of the FIRST LED in the FIRST MATRIX; pick two, e.g.
//     NEO_MATRIX_TOP + NEO_MATRIX_LEFT for the top-left corner.
//   NEO_MATRIX_ROWS, NEO_MATRIX_COLUMNS: LEDs WITHIN EACH MATRIX are
//     arranged in horizontal rows or in vertical columns, respectively;
//     pick one or the other.
//   NEO_MATRIX_PROGRESSIVE, NEO_MATRIX_ZIGZAG: all rows/columns WITHIN
//     EACH MATRIX proceed in the same order, or alternate lines reverse
//     direction; pick one.
//   NEO_TILE_TOP, NEO_TILE_BOTTOM, NEO_TILE_LEFT, NEO_TILE_RIGHT:
//     Position of the FIRST MATRIX (tile) in the OVERALL DISPLAY; pick
//     two, e.g. NEO_TILE_TOP + NEO_TILE_LEFT for the top-left corner.
//   NEO_TILE_ROWS, NEO_TILE_COLUMNS: the matrices in the OVERALL DISPLAY
//     are arranged in horizontal rows or in vertical columns, respectively;
//     pick one or the other.
//   NEO_TILE_PROGRESSIVE, NEO_TILE_ZIGZAG: the ROWS/COLUMS OF MATRICES
//     (tiles) in the OVERALL DISPLAY proceed in the same order for every
//     line, or alternate lines reverse direction; pick one.  When using
//     zig-zag order, the orientation of the matrices in alternate rows
//     will be rotated 180 degrees (this is normal -- simplifies wiring).
//   See example below for these values in action.

//#if defined(P16BY16X4)
//#define MX_WIDTH 32
//#define MX_HEIGHT 32
//#define NUM_LEDS (MX_WIDTH*MX_HEIGHT)
//CRGB leds[NUM_LEDS];
//FastLED_NeoMatrix *matrix = new FastLED_NeoMatrix(leds, 16, 16, 2, 2, 
//  NEO_MATRIX_BOTTOM     + NEO_MATRIX_RIGHT +
//    NEO_MATRIX_COLUMNS + NEO_MATRIX_ZIGZAG + 
//    NEO_TILE_TOP + NEO_TILE_RIGHT +  NEO_TILE_PROGRESSIVE);
//
//#elif defined(P32BY8X3)
//#define MX_WIDTH 24
//#define MX_HEIGHT 32
//#define NUM_LEDS (MX_WIDTH*MX_HEIGHT)
//CRGB leds[NUM_LEDS];
//FastLED_NeoMatrix *matrix = new FastLED_NeoMatrix(leds, 8, 32, 3, 1, 
//  NEO_MATRIX_TOP     + NEO_MATRIX_RIGHT +
//    NEO_MATRIX_ROWS + NEO_MATRIX_ZIGZAG + 
//    NEO_TILE_TOP + NEO_TILE_LEFT +  NEO_TILE_PROGRESSIVE);
//
//#else




// This could also be defined as matrix->color(255,0,0) but those defines
// are meant to work for adafruit_gfx backends that are lacking color()
#define LED_BLACK    0

#define LED_RED_VERYLOW   (3 <<  11)
#define LED_RED_LOW     (7 <<  11)
#define LED_RED_MEDIUM    (15 << 11)
#define LED_RED_HIGH    (31 << 11)

#define LED_GREEN_VERYLOW (1 <<  5)   
#define LED_GREEN_LOW     (15 << 5)  
#define LED_GREEN_MEDIUM  (31 << 5)  
#define LED_GREEN_HIGH    (63 << 5)  

#define LED_BLUE_VERYLOW  3
#define LED_BLUE_LOW    7
#define LED_BLUE_MEDIUM   15
#define LED_BLUE_HIGH     31

#define LED_ORANGE_VERYLOW  (LED_RED_VERYLOW + LED_GREEN_VERYLOW)
#define LED_ORANGE_LOW    (LED_RED_LOW     + LED_GREEN_LOW)
#define LED_ORANGE_MEDIUM (LED_RED_MEDIUM  + LED_GREEN_MEDIUM)
#define LED_ORANGE_HIGH   (LED_RED_HIGH    + LED_GREEN_HIGH)

#define LED_PURPLE_VERYLOW  (LED_RED_VERYLOW + LED_BLUE_VERYLOW)
#define LED_PURPLE_LOW    (LED_RED_LOW     + LED_BLUE_LOW)
#define LED_PURPLE_MEDIUM (LED_RED_MEDIUM  + LED_BLUE_MEDIUM)
#define LED_PURPLE_HIGH   (LED_RED_HIGH    + LED_BLUE_HIGH)

#define LED_CYAN_VERYLOW  (LED_GREEN_VERYLOW + LED_BLUE_VERYLOW)
#define LED_CYAN_LOW    (LED_GREEN_LOW     + LED_BLUE_LOW)
#define LED_CYAN_MEDIUM   (LED_GREEN_MEDIUM  + LED_BLUE_MEDIUM)
#define LED_CYAN_HIGH   (LED_GREEN_HIGH    + LED_BLUE_HIGH)

#define LED_WHITE_VERYLOW (LED_RED_VERYLOW + LED_GREEN_VERYLOW + LED_BLUE_VERYLOW)
#define LED_WHITE_LOW   (LED_RED_LOW     + LED_GREEN_LOW     + LED_BLUE_LOW)
#define LED_WHITE_MEDIUM  (LED_RED_MEDIUM  + LED_GREEN_MEDIUM  + LED_BLUE_MEDIUM)
#define LED_WHITE_HIGH    (LED_RED_HIGH    + LED_GREEN_HIGH    + LED_BLUE_HIGH)

static const uint8_t PROGMEM
    mono_bmp[][8] =
    {
  {   // 0: checkered 1
      B10101010,
      B01010101,
      B10101010,
      B01010101,
      B10101010,
      B01010101,
      B10101010,
      B01010101,
      },

  {   // 1: checkered 2
      B01010101,
      B10101010,
      B01010101,
      B10101010,
      B01010101,
      B10101010,
      B01010101,
      B10101010,
      },

  {   // 2: smiley
      B00111100,
      B01000010,
      B10100101,
      B10000001,
      B10100101,
      B10011001,
      B01000010,
      B00111100 },

  {   // 3: neutral
      B00111100,
      B01000010,
      B10100101,
      B10000001,
      B10111101,
      B10000001,
      B01000010,
      B00111100 },

  {   // 4; frowny
      B00111100,
      B01000010,
      B10100101,
      B10000001,
      B10011001,
      B10100101,
      B01000010,
      B00111100 },
    };


static const uint16_t PROGMEM
    // These bitmaps were written for a backend that only supported
    // 4 bits per color with Blue/Green/Red ordering while neomatrix
    // uses native 565 color mapping as RGB.  
    // I'm leaving the arrays as is because it's easier to read
    // which color is what when separated on a 4bit boundary
    // The demo code will modify the arrays at runtime to be compatible
    // with the neomatrix color ordering and bit depth.
    RGB_bmp[][64] = {
      // 00: blue, blue/red, red, red/green, green, green/blue, blue, white
      { 0x100, 0x200, 0x300, 0x400, 0x600, 0x800, 0xA00, 0xF00, 
  0x101, 0x202, 0x303, 0x404, 0x606, 0x808, 0xA0A, 0xF0F, 
        0x001, 0x002, 0x003, 0x004, 0x006, 0x008, 0x00A, 0x00F, 
  0x011, 0x022, 0x033, 0x044, 0x066, 0x088, 0x0AA, 0x0FF, 
  0x010, 0x020, 0x030, 0x040, 0x060, 0x080, 0x0A0, 0x0F0, 
  0x110, 0x220, 0x330, 0x440, 0x660, 0x880, 0xAA0, 0xFF0, 
  0x100, 0x200, 0x300, 0x400, 0x600, 0x800, 0xA00, 0xF00, 
  0x111, 0x222, 0x333, 0x444, 0x666, 0x888, 0xAAA, 0xFFF, },

      // 01: grey to white
      { 0x111, 0x222, 0x333, 0x555, 0x777, 0x999, 0xAAA, 0xFFF, 
  0x222, 0x222, 0x333, 0x555, 0x777, 0x999, 0xAAA, 0xFFF, 
  0x333, 0x333, 0x333, 0x555, 0x777, 0x999, 0xAAA, 0xFFF, 
  0x555, 0x555, 0x555, 0x555, 0x777, 0x999, 0xAAA, 0xFFF, 
  0x777, 0x777, 0x777, 0x777, 0x777, 0x999, 0xAAA, 0xFFF, 
  0x999, 0x999, 0x999, 0x999, 0x999, 0x999, 0xAAA, 0xFFF, 
  0xAAA, 0xAAA, 0xAAA, 0xAAA, 0xAAA, 0xAAA, 0xAAA, 0xFFF, 
  0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, 0xFFF, },

      // 02: low red to high red
      { 0x001, 0x002, 0x003, 0x005, 0x007, 0x009, 0x00A, 0x00F, 
  0x002, 0x002, 0x003, 0x005, 0x007, 0x009, 0x00A, 0x00F, 
  0x003, 0x003, 0x003, 0x005, 0x007, 0x009, 0x00A, 0x00F, 
  0x005, 0x005, 0x005, 0x005, 0x007, 0x009, 0x00A, 0x00F, 
  0x007, 0x007, 0x007, 0x007, 0x007, 0x009, 0x00A, 0x00F, 
  0x009, 0x009, 0x009, 0x009, 0x009, 0x009, 0x00A, 0x00F, 
  0x00A, 0x00A, 0x00A, 0x00A, 0x00A, 0x00A, 0x00A, 0x00F, 
  0x00F, 0x00F, 0x00F, 0x00F, 0x00F, 0x00F, 0x00F, 0x00F, },

      // 03: low green to high green
      { 0x010, 0x020, 0x030, 0x050, 0x070, 0x090, 0x0A0, 0x0F0, 
  0x020, 0x020, 0x030, 0x050, 0x070, 0x090, 0x0A0, 0x0F0, 
  0x030, 0x030, 0x030, 0x050, 0x070, 0x090, 0x0A0, 0x0F0, 
  0x050, 0x050, 0x050, 0x050, 0x070, 0x090, 0x0A0, 0x0F0, 
  0x070, 0x070, 0x070, 0x070, 0x070, 0x090, 0x0A0, 0x0F0, 
  0x090, 0x090, 0x090, 0x090, 0x090, 0x090, 0x0A0, 0x0F0, 
  0x0A0, 0x0A0, 0x0A0, 0x0A0, 0x0A0, 0x0A0, 0x0A0, 0x0F0, 
  0x0F0, 0x0F0, 0x0F0, 0x0F0, 0x0F0, 0x0F0, 0x0F0, 0x0F0, },

      // 04: low blue to high blue
      { 0x100, 0x200, 0x300, 0x500, 0x700, 0x900, 0xA00, 0xF00, 
  0x200, 0x200, 0x300, 0x500, 0x700, 0x900, 0xA00, 0xF00, 
  0x300, 0x300, 0x300, 0x500, 0x700, 0x900, 0xA00, 0xF00, 
  0x500, 0x500, 0x500, 0x500, 0x700, 0x900, 0xA00, 0xF00, 
  0x700, 0x700, 0x700, 0x700, 0x700, 0x900, 0xA00, 0xF00, 
  0x900, 0x900, 0x900, 0x900, 0x900, 0x900, 0xA00, 0xF00, 
  0xA00, 0xA00, 0xA00, 0xA00, 0xA00, 0xA00, 0xA00, 0xF00, 
  0xF00, 0xF00, 0xF00, 0xF00, 0xF00, 0xF00, 0xF00, 0xF00, },

      // 05: 1 black, 2R, 2O, 2G, 1B with 4 blue lines rising right
      { 0x000, 0x200, 0x000, 0x400, 0x000, 0x800, 0x000, 0xF00, 
        0x000, 0x201, 0x002, 0x403, 0x004, 0x805, 0x006, 0xF07, 
  0x008, 0x209, 0x00A, 0x40B, 0x00C, 0x80D, 0x00E, 0xF0F, 
  0x000, 0x211, 0x022, 0x433, 0x044, 0x855, 0x066, 0xF77, 
  0x088, 0x299, 0x0AA, 0x4BB, 0x0CC, 0x8DD, 0x0EE, 0xFFF, 
  0x000, 0x210, 0x020, 0x430, 0x040, 0x850, 0x060, 0xF70, 
  0x080, 0x290, 0x0A0, 0x4B0, 0x0C0, 0x8D0, 0x0E0, 0xFF0,
  0x000, 0x200, 0x000, 0x500, 0x000, 0x800, 0x000, 0xF00, },

      // 06: 4 lines of increasing red and then green
      { 0x000, 0x000, 0x001, 0x001, 0x002, 0x002, 0x003, 0x003, 
  0x004, 0x004, 0x005, 0x005, 0x006, 0x006, 0x007, 0x007, 
  0x008, 0x008, 0x009, 0x009, 0x00A, 0x00A, 0x00B, 0x00B, 
  0x00C, 0x00C, 0x00D, 0x00D, 0x00E, 0x00E, 0x00F, 0x00F, 
  0x000, 0x000, 0x010, 0x010, 0x020, 0x020, 0x030, 0x030, 
  0x040, 0x040, 0x050, 0x050, 0x060, 0x060, 0x070, 0x070, 
  0x080, 0x080, 0x090, 0x090, 0x0A0, 0x0A0, 0x0B0, 0x0B0, 
  0x0C0, 0x0C0, 0x0D0, 0x0D0, 0x0E0, 0x0E0, 0x0F0, 0x0F0, },

      // 07: 4 lines of increasing red and then blue
      { 0x000, 0x000, 0x001, 0x001, 0x002, 0x002, 0x003, 0x003, 
  0x004, 0x004, 0x005, 0x005, 0x006, 0x006, 0x007, 0x007, 
  0x008, 0x008, 0x009, 0x009, 0x00A, 0x00A, 0x00B, 0x00B, 
  0x00C, 0x00C, 0x00D, 0x00D, 0x00E, 0x00E, 0x00F, 0x00F, 
  0x000, 0x000, 0x100, 0x100, 0x200, 0x200, 0x300, 0x300, 
  0x400, 0x400, 0x500, 0x500, 0x600, 0x600, 0x700, 0x700, 
  0x800, 0x800, 0x900, 0x900, 0xA00, 0xA00, 0xB00, 0xB00, 
  0xC00, 0xC00, 0xD00, 0xD00, 0xE00, 0xE00, 0xF00, 0xF00, },

      // 08: criss cross of green and red with diagonal blue.
      { 0xF00, 0x001, 0x003, 0x005, 0x007, 0x00A, 0x00F, 0x000, 
  0x020, 0xF21, 0x023, 0x025, 0x027, 0x02A, 0x02F, 0x020, 
  0x040, 0x041, 0xF43, 0x045, 0x047, 0x04A, 0x04F, 0x040, 
  0x060, 0x061, 0x063, 0xF65, 0x067, 0x06A, 0x06F, 0x060, 
  0x080, 0x081, 0x083, 0x085, 0xF87, 0x08A, 0x08F, 0x080, 
  0x0A0, 0x0A1, 0x0A3, 0x0A5, 0x0A7, 0xFAA, 0x0AF, 0x0A0, 
  0x0F0, 0x0F1, 0x0F3, 0x0F5, 0x0F7, 0x0FA, 0xFFF, 0x0F0, 
  0x000, 0x001, 0x003, 0x005, 0x007, 0x00A, 0x00F, 0xF00, },

      // 09: 2 lines of green, 2 red, 2 orange, 2 green
      { 0x0F0, 0x0F0, 0x0FF, 0x0FF, 0x00F, 0x00F, 0x0F0, 0x0F0, 
  0x0F0, 0x0F0, 0x0FF, 0x0FF, 0x00F, 0x00F, 0x0F0, 0x0F0, 
  0x0F0, 0x0F0, 0x0FF, 0x0FF, 0x00F, 0x00F, 0x0F0, 0x0F0, 
  0x0F0, 0x0F0, 0x0FF, 0x0FF, 0x00F, 0x00F, 0x0F0, 0x0F0, 
  0x0F0, 0x0F0, 0x0FF, 0x0FF, 0x00F, 0x00F, 0x0F0, 0x0F0, 
  0x0F0, 0x0F0, 0x0FF, 0x0FF, 0x00F, 0x00F, 0x0F0, 0x0F0, 
  0x0F0, 0x0F0, 0x0FF, 0x0FF, 0x00F, 0x00F, 0x0F0, 0x0F0, 
  0x0F0, 0x0F0, 0x0FF, 0x0FF, 0x00F, 0x00F, 0x0F0, 0x0F0, },

      // 10: multicolor smiley face
      { 0x000, 0x000, 0x00F, 0x00F, 0x00F, 0x00F, 0x000, 0x000, 
  0x000, 0x00F, 0x000, 0x000, 0x000, 0x000, 0x00F, 0x000, 
  0x00F, 0x000, 0xF00, 0x000, 0x000, 0xF00, 0x000, 0x00F, 
  0x00F, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x00F, 
  0x00F, 0x000, 0x0F0, 0x000, 0x000, 0x0F0, 0x000, 0x00F, 
  0x00F, 0x000, 0x000, 0x0F4, 0x0F3, 0x000, 0x000, 0x00F, 
  0x000, 0x00F, 0x000, 0x000, 0x000, 0x000, 0x00F, 0x000, 
  0x000, 0x000, 0x00F, 0x00F, 0x00F, 0x00F, 0x000, 0x000, },
};


#endif
